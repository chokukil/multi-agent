"""
üçí CherryAI MCP Ïó∞Í≤∞ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏä§ÌÖú

LLM First ÏõêÏπôÏùÑ Ï§ÄÏàòÌïòÎäî MCP ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÏïàÏ†ïÏÑ± Í¥ÄÎ¶¨
- JSON ÏÑ§Ï†ï ÌååÏùº Í∏∞Î∞ò ÏÑúÎ≤Ñ Í¥ÄÎ¶¨
- Ïã§ÏãúÍ∞Ñ Ïó∞Í≤∞ ÏÉÅÌÉú Ï≤¥ÌÅ¨
- ÏûêÎèô Ìó¨Ïä§Ï≤¥ÌÅ¨ ÏóîÎìúÌè¨Ïù∏Ìä∏
- Ïó∞Í≤∞ Ïã§Ìå® ÏïåÎ¶º ÏãúÏä§ÌÖú
- ÏßÄÏàò Î∞±Ïò§ÌîÑ Ïû¨ÏãúÎèÑ Î©îÏª§ÎãàÏ¶ò
"""

import asyncio
import time
import logging
from datetime import datetime, timedelta
from enum import Enum
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Callable, Any, Tuple
from pathlib import Path
import json
import httpx
import subprocess

# ÏÑ§Ï†ï Í¥ÄÎ¶¨Ïûê ÌÜµÌï©
from .mcp_config_manager import (
    get_mcp_config_manager,
    MCPServerDefinition,
    MCPServerType,
    MCPConfigManager
)

from .mcp_auto_recovery import get_auto_recovery, MCPAutoRecovery

logger = logging.getLogger(__name__)

class MCPConnectionStatus(Enum):
    """MCP Ïó∞Í≤∞ ÏÉÅÌÉú"""
    CONNECTED = "connected"
    CONNECTING = "connecting"
    DISCONNECTED = "disconnected"
    FAILED = "failed"
    UNKNOWN = "unknown"

@dataclass
class MCPHealthCheckResult:
    """MCP Ìó¨Ïä§Ï≤¥ÌÅ¨ Í≤∞Í≥º"""
    server_name: str
    status: MCPConnectionStatus
    response_time: float
    timestamp: datetime
    error_message: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class MCPServerConfig:
    """Í∏∞Ï°¥ Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌïú MCP ÏÑúÎ≤Ñ ÏÑ§Ï†ï (Deprecated)"""
    name: str
    endpoint: str
    health_check_path: str = "/health"
    timeout: float = 5.0
    retry_count: int = 3
    retry_delay: float = 1.0
    backoff_multiplier: float = 2.0

class MCPConnectionMonitor:
    """MCP ÏÑúÎ≤Ñ Ïó∞Í≤∞ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏä§ÌÖú (ÏûêÎèô Î≥µÍµ¨ ÌÜµÌï©)"""
    
    def __init__(self, config_manager: Optional[MCPConfigManager] = None):
        self.config_manager = config_manager or MCPConfigManager()
        self.connections = {}
        self.server_stats = {}
        self.monitoring_active = False
        self.last_scan_time = None
        
        # ÏûêÎèô Î≥µÍµ¨ ÏãúÏä§ÌÖú ÌÜµÌï©
        self.auto_recovery: MCPAutoRecovery = get_auto_recovery(self.config_manager)
        
        logger.info("MCP Connection Monitor with Auto Recovery Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
    
    async def start_monitoring(self):
        """Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë (ÏûêÎèô Î≥µÍµ¨ Ìè¨Ìï®)"""
        if self.monitoring_active:
            return
        
        self.monitoring_active = True
        logger.info("üîç MCP Ïó∞Í≤∞ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë (ÏûêÎèô Î≥µÍµ¨ ÌôúÏÑ±Ìôî)")
        
        # ÏûêÎèô Î≥µÍµ¨ Î™®ÎãàÌÑ∞ÎßÅÎèÑ Ìï®Íªò ÏãúÏûë
        recovery_task = asyncio.create_task(self.auto_recovery.start_monitoring())
        monitor_task = asyncio.create_task(self._monitor_loop())
        
        try:
            await asyncio.gather(recovery_task, monitor_task)
        except Exception as e:
            logger.error(f"Î™®ÎãàÌÑ∞ÎßÅ Ïò§Î•ò: {e}")
            self.monitoring_active = False

    async def _monitor_loop(self):
        """Î™®ÎãàÌÑ∞ÎßÅ Î£®ÌîÑ"""
        while self.monitoring_active:
            try:
                # ÏÑúÎ≤Ñ Î∞úÍ≤¨ Î∞è ÏÉÅÌÉú Ï≤¥ÌÅ¨
                await self.discover_servers()
                await self.check_all_connections()
                
                # 30Ï¥à ÎåÄÍ∏∞
                await asyncio.sleep(30)
                
            except Exception as e:
                logger.error(f"Î™®ÎãàÌÑ∞ÎßÅ Î£®ÌîÑ Ïò§Î•ò: {e}")
                await asyncio.sleep(5)

    async def discover_servers(self):
        """MCP ÏÑúÎ≤Ñ ÏûêÎèô Î∞úÍ≤¨"""
        try:
            servers_config = self.config_manager.get_all_servers()
            discovered_count = 0
            
            for server_id, config in servers_config.items():
                if not config.get("enabled", True):
                    continue
                
                server_type = config.get("type", "stdio")
                
                # ÏÉàÎ°úÏö¥ ÏÑúÎ≤Ñ Î∞úÍ≤¨ Ïãú ÏûêÎèô ÏãúÏûë ÏãúÎèÑ
                if server_id not in self.connections:
                    logger.info(f"üîç ÏÉàÎ°úÏö¥ MCP ÏÑúÎ≤Ñ Î∞úÍ≤¨: {server_id} ({server_type})")
                    
                    # ÏûêÎèô Î≥µÍµ¨ ÏãúÏä§ÌÖúÏùÑ ÌÜµÌï¥ ÏÑúÎ≤Ñ ÏãúÏûë
                    success = await self.auto_recovery.start_server(server_id)
                    if success:
                        discovered_count += 1
                        self.connections[server_id] = {
                            "type": server_type,
                            "config": config,
                            "status": "starting",
                            "last_check": datetime.now()
                        }
            
            if discovered_count > 0:
                logger.info(f"‚úÖ {discovered_count}Í∞ú MCP ÏÑúÎ≤Ñ ÏûêÎèô ÏãúÏûë ÏôÑÎ£å")
            
            self.last_scan_time = datetime.now()
            
        except Exception as e:
            logger.error(f"ÏÑúÎ≤Ñ Î∞úÍ≤¨ Ï§ë Ïò§Î•ò: {e}")

    async def check_all_connections(self):
        """Î™®Îì† Ïó∞Í≤∞ ÏÉÅÌÉú Ï≤¥ÌÅ¨"""
        if not self.connections:
            return
        
        tasks = []
        for server_id in self.connections.keys():
            task = asyncio.create_task(self._check_single_connection(server_id))
            tasks.append(task)
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        healthy_count = sum(1 for r in results if r is True)
        total_count = len(results)
        
        logger.debug(f"üìä Ïó∞Í≤∞ ÏÉÅÌÉú Ï≤¥ÌÅ¨ ÏôÑÎ£å: {healthy_count}/{total_count} Ï†ïÏÉÅ")

    async def _check_single_connection(self, server_id: str) -> bool:
        """Îã®Ïùº ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ï≤¥ÌÅ¨"""
        try:
            # ÏûêÎèô Î≥µÍµ¨ ÏãúÏä§ÌÖúÏùò Í±¥Í∞ï Ï≤¥ÌÅ¨ ÌôúÏö©
            is_healthy = await self.auto_recovery.check_server_health(server_id)
            
            # Ïó∞Í≤∞ Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
            if server_id in self.connections:
                self.connections[server_id]["status"] = "healthy" if is_healthy else "unhealthy"
                self.connections[server_id]["last_check"] = datetime.now()
            
            # ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
            self._update_server_stats(server_id, is_healthy)
            
            return is_healthy
            
        except Exception as e:
            logger.error(f"ÏÑúÎ≤Ñ {server_id} Ïó∞Í≤∞ Ï≤¥ÌÅ¨ Ïã§Ìå®: {e}")
            if server_id in self.connections:
                self.connections[server_id]["status"] = "error"
            return False

    def _update_server_stats(self, server_id: str, is_healthy: bool):
        """ÏÑúÎ≤Ñ ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏"""
        if server_id not in self.server_stats:
            self.server_stats[server_id] = {
                "total_checks": 0,
                "successful_checks": 0,
                "failed_checks": 0,
                "uptime_percentage": 0.0,
                "last_success": None,
                "last_failure": None
            }
        
        stats = self.server_stats[server_id]
        stats["total_checks"] += 1
        
        if is_healthy:
            stats["successful_checks"] += 1
            stats["last_success"] = datetime.now()
        else:
            stats["failed_checks"] += 1
            stats["last_failure"] = datetime.now()
        
        # Í∞ÄÏö©ÏÑ± Í≥ÑÏÇ∞
        if stats["total_checks"] > 0:
            stats["uptime_percentage"] = (stats["successful_checks"] / stats["total_checks"]) * 100

    def get_connection_summary(self) -> Dict[str, Any]:
        """Ïó∞Í≤∞ ÏÉÅÌÉú ÏöîÏïΩ (ÏûêÎèô Î≥µÍµ¨ Ï†ïÎ≥¥ Ìè¨Ìï®)"""
        healthy_servers = sum(1 for conn in self.connections.values() if conn.get("status") == "healthy")
        total_servers = len(self.connections)
        
        # ÏûêÎèô Î≥µÍµ¨ ÏãúÏä§ÌÖúÏùò Í±¥Í∞ï ÏÉÅÌÉú Ï†ïÎ≥¥ ÌÜµÌï©
        auto_recovery_summary = self.auto_recovery.get_health_summary()
        
        summary = {
            "monitoring_status": "active" if self.monitoring_active else "inactive",
            "timestamp": datetime.now().isoformat(),
            "last_scan": self.last_scan_time.isoformat() if self.last_scan_time else None,
            "total_servers": total_servers,
            "healthy_servers": healthy_servers,
            "unhealthy_servers": total_servers - healthy_servers,
            "uptime_percentage": (healthy_servers / total_servers * 100) if total_servers > 0 else 0,
            "auto_recovery": {
                "enabled": True,
                "circuit_breakers": auto_recovery_summary.get("servers", {}),
                "total_recovery_attempts": sum(
                    server.get("recovery_attempts", 0) 
                    for server in auto_recovery_summary.get("servers", {}).values()
                )
            },
            "servers": {}
        }
        
        # ÏÑúÎ≤ÑÎ≥Ñ ÏÉÅÏÑ∏ Ï†ïÎ≥¥
        for server_id, connection in self.connections.items():
            server_config = connection.get("config", {})
            server_stats = self.server_stats.get(server_id, {})
            auto_recovery_info = auto_recovery_summary.get("servers", {}).get(server_id, {})
            
            summary["servers"][server_id] = {
                "name": server_config.get("name", server_id),
                "type": connection.get("type", "unknown"),
                "status": connection.get("status", "unknown"),
                "last_check": connection.get("last_check", datetime.now()).isoformat(),
                "uptime_percentage": server_stats.get("uptime_percentage", 0.0),
                "total_checks": server_stats.get("total_checks", 0),
                "circuit_state": auto_recovery_info.get("circuit_state", "unknown"),
                "failure_count": auto_recovery_info.get("failure_count", 0),
                "recovery_attempts": auto_recovery_info.get("recovery_attempts", 0),
                "avg_response_time": auto_recovery_info.get("avg_response_time", 0.0),
                "capabilities": server_config.get("capabilities", []),
                "enabled": server_config.get("enabled", True)
            }
        
        return summary

    async def force_recovery(self, server_id: str) -> bool:
        """ÏàòÎèô Î≥µÍµ¨ Í∞ïÏ†ú Ïã§Ìñâ"""
        try:
            logger.info(f"üîÑ ÏÑúÎ≤Ñ {server_id} ÏàòÎèô Î≥µÍµ¨ ÏãúÏûë")
            success = await self.auto_recovery.auto_retry_connection(server_id)
            
            if success:
                logger.info(f"‚úÖ ÏÑúÎ≤Ñ {server_id} ÏàòÎèô Î≥µÍµ¨ ÏÑ±Í≥µ")
            else:
                logger.warning(f"‚ùå ÏÑúÎ≤Ñ {server_id} ÏàòÎèô Î≥µÍµ¨ Ïã§Ìå®")
            
            return success
            
        except Exception as e:
            logger.error(f"ÏÑúÎ≤Ñ {server_id} ÏàòÎèô Î≥µÍµ¨ Ï§ë Ïò§Î•ò: {e}")
            return False

    async def restart_server(self, server_id: str) -> bool:
        """ÏÑúÎ≤Ñ Ïû¨ÏãúÏûë"""
        try:
            logger.info(f"üîÑ ÏÑúÎ≤Ñ {server_id} Ïû¨ÏãúÏûë ÏãúÏûë")
            success = await self.auto_recovery.restart_server(server_id)
            
            if success:
                logger.info(f"‚úÖ ÏÑúÎ≤Ñ {server_id} Ïû¨ÏãúÏûë ÏÑ±Í≥µ")
                # Ïó∞Í≤∞ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
                if server_id in self.connections:
                    self.connections[server_id]["status"] = "starting"
            else:
                logger.warning(f"‚ùå ÏÑúÎ≤Ñ {server_id} Ïû¨ÏãúÏûë Ïã§Ìå®")
            
            return success
            
        except Exception as e:
            logger.error(f"ÏÑúÎ≤Ñ {server_id} Ïû¨ÏãúÏûë Ï§ë Ïò§Î•ò: {e}")
            return False

    async def stop_monitoring(self):
        """Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏßÄ"""
        self.monitoring_active = False
        
        # ÏûêÎèô Î≥µÍµ¨ ÏãúÏä§ÌÖúÎèÑ Ìï®Íªò Ï¢ÖÎ£å
        await self.auto_recovery.shutdown()
        
        logger.info("üõë MCP Ïó∞Í≤∞ Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏßÄ")

    def get_server_types_summary(self) -> Dict[str, int]:
        """ÏÑúÎ≤Ñ ÌÉÄÏûÖÎ≥Ñ ÏöîÏïΩ"""
        type_counts = {"stdio": 0, "sse": 0, "unknown": 0}
        
        for connection in self.connections.values():
            server_type = connection.get("type", "unknown")
            if server_type in type_counts:
                type_counts[server_type] += 1
            else:
                type_counts["unknown"] += 1
        
        return type_counts

# Ï†ÑÏó≠ Î™®ÎãàÌÑ∞ Ïù∏Ïä§ÌÑ¥Ïä§
_mcp_monitor = None

def get_mcp_monitor() -> MCPConnectionMonitor:
    """Ï†ÑÏó≠ MCP Î™®ÎãàÌÑ∞ Ïù∏Ïä§ÌÑ¥Ïä§ Î∞òÌôò"""
    global _mcp_monitor
    if _mcp_monitor is None:
        _mcp_monitor = MCPConnectionMonitor()
    return _mcp_monitor 