"""
Domain-Specific Answer Formatter Module

This module provides domain-specific formatting for answers generated by the 
Holistic Answer Synthesis Engine, ensuring that responses are presented in 
the most appropriate format for each domain.

Author: CherryAI Development Team
Version: 1.0.0
"""

import logging
from typing import Dict, List, Optional, Any, Union, Tuple
from dataclasses import dataclass, field
from enum import Enum
from datetime import datetime
import json
import re

from .holistic_answer_synthesis_engine import HolisticAnswer, AnswerSection, AnswerStyle
from .intent_analyzer import DetailedIntentAnalysis
from .domain_extractor import EnhancedDomainKnowledge
from .intelligent_query_processor import DomainType as IQPDomainType

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class DomainType(Enum):
    """Supported domain types for specialized formatting"""
    TECHNICAL = "technical"
    BUSINESS = "business"
    FINANCIAL = "financial"
    SCIENTIFIC = "scientific"
    MEDICAL = "medical"
    LEGAL = "legal"
    EDUCATIONAL = "educational"
    MARKETING = "marketing"
    OPERATIONS = "operations"
    ANALYTICS = "analytics"
    GENERAL = "general"


class OutputFormat(Enum):
    """Available output formats for domain-specific answers"""
    STRUCTURED_TEXT = "structured_text"
    MARKDOWN = "markdown"
    HTML = "html"
    JSON = "json"
    EXECUTIVE_SUMMARY = "executive_summary"
    TECHNICAL_REPORT = "technical_report"
    PRESENTATION = "presentation"
    DASHBOARD = "dashboard"
    NARRATIVE = "narrative"
    BULLET_POINTS = "bullet_points"


class FormattingStyle(Enum):
    """Formatting styles for different audiences"""
    EXECUTIVE = "executive"
    TECHNICAL = "technical"
    OPERATIONAL = "operational"
    ACADEMIC = "academic"
    CASUAL = "casual"
    FORMAL = "formal"


@dataclass
class DomainFormattingRules:
    """Domain-specific formatting rules and conventions"""
    domain: DomainType
    terminology: Dict[str, str] = field(default_factory=dict)
    section_order: List[str] = field(default_factory=list)
    required_sections: List[str] = field(default_factory=list)
    formatting_conventions: Dict[str, Any] = field(default_factory=dict)
    citation_style: str = "standard"
    metric_units: Dict[str, str] = field(default_factory=dict)
    visualization_preferences: List[str] = field(default_factory=list)


@dataclass
class FormattingContext:
    """Context information for answer formatting"""
    domain: DomainType
    output_format: OutputFormat
    style: FormattingStyle
    target_audience: str
    use_technical_terms: bool = True
    include_visualizations: bool = True
    max_length: Optional[int] = None
    priority_sections: List[str] = field(default_factory=list)


@dataclass
class FormattedAnswer:
    """Formatted answer with domain-specific presentation"""
    content: str
    format_type: OutputFormat
    domain: DomainType
    style: FormattingStyle
    metadata: Dict[str, Any] = field(default_factory=dict)
    sections: List[Dict[str, str]] = field(default_factory=list)
    visualizations: List[Dict[str, Any]] = field(default_factory=list)
    citations: List[str] = field(default_factory=list)
    generated_at: datetime = field(default_factory=datetime.now)


class DomainSpecificAnswerFormatter:
    """
    Formats answers with domain-specific conventions and requirements
    """
    
    def __init__(self):
        """Initialize the Domain-Specific Answer Formatter"""
        self.logger = logging.getLogger(__name__)
        self.domain_rules = self._initialize_domain_rules()
        self.formatting_templates = self._initialize_formatting_templates()
        self.terminology_maps = self._initialize_terminology_maps()
        
    def _initialize_domain_rules(self) -> Dict[DomainType, DomainFormattingRules]:
        """Initialize domain-specific formatting rules"""
        return {
            DomainType.TECHNICAL: DomainFormattingRules(
                domain=DomainType.TECHNICAL,
                section_order=["executive_summary", "technical_analysis", "implementation", "risks", "recommendations"],
                required_sections=["technical_analysis", "implementation"],
                formatting_conventions={
                    "code_blocks": True,
                    "technical_diagrams": True,
                    "detailed_explanations": True,
                    "step_by_step": True
                },
                citation_style="ieee",
                metric_units={"performance": "ms", "memory": "MB", "storage": "GB"},
                visualization_preferences=["architecture_diagrams", "flowcharts", "performance_graphs"]
            ),
            DomainType.BUSINESS: DomainFormattingRules(
                domain=DomainType.BUSINESS,
                section_order=["executive_summary", "business_impact", "financial_analysis", "recommendations", "next_steps"],
                required_sections=["executive_summary", "business_impact"],
                formatting_conventions={
                    "executive_focus": True,
                    "roi_calculations": True,
                    "timeline_emphasis": True,
                    "risk_assessment": True
                },
                citation_style="business",
                metric_units={"revenue": "$", "time": "days", "resources": "FTE"},
                visualization_preferences=["charts", "graphs", "dashboards", "timelines"]
            ),
            DomainType.FINANCIAL: DomainFormattingRules(
                domain=DomainType.FINANCIAL,
                section_order=["executive_summary", "financial_analysis", "risk_assessment", "projections", "recommendations"],
                required_sections=["financial_analysis", "risk_assessment"],
                formatting_conventions={
                    "financial_tables": True,
                    "percentage_formatting": True,
                    "currency_formatting": True,
                    "compliance_notes": True
                },
                citation_style="financial",
                metric_units={"currency": "$", "percentage": "%", "ratio": "x"},
                visualization_preferences=["financial_charts", "trend_graphs", "comparison_tables"]
            ),
            DomainType.SCIENTIFIC: DomainFormattingRules(
                domain=DomainType.SCIENTIFIC,
                section_order=["abstract", "methodology", "results", "discussion", "conclusion"],
                required_sections=["methodology", "results"],
                formatting_conventions={
                    "scientific_notation": True,
                    "statistical_significance": True,
                    "peer_review_style": True,
                    "hypothesis_testing": True
                },
                citation_style="apa",
                metric_units={"measurement": "SI", "statistical": "p-value", "confidence": "CI"},
                visualization_preferences=["scientific_plots", "statistical_charts", "data_visualizations"]
            ),
            DomainType.ANALYTICS: DomainFormattingRules(
                domain=DomainType.ANALYTICS,
                section_order=["executive_summary", "data_overview", "analysis", "insights", "recommendations"],
                required_sections=["data_overview", "analysis", "insights"],
                formatting_conventions={
                    "data_tables": True,
                    "statistical_summaries": True,
                    "trend_analysis": True,
                    "predictive_insights": True
                },
                citation_style="data",
                metric_units={"correlation": "r", "variance": "σ²", "confidence": "%"},
                visualization_preferences=["dashboards", "charts", "heatmaps", "trend_lines"]
            ),
            DomainType.GENERAL: DomainFormattingRules(
                domain=DomainType.GENERAL,
                section_order=["executive_summary", "analysis", "recommendations", "next_steps"],
                required_sections=["analysis", "recommendations"],
                formatting_conventions={
                    "clear_structure": True,
                    "balanced_detail": True,
                    "actionable_insights": True
                },
                citation_style="standard",
                metric_units={"general": "units"},
                visualization_preferences=["charts", "graphs", "tables"]
            )
        }
    
    def _initialize_formatting_templates(self) -> Dict[OutputFormat, str]:
        """Initialize formatting templates for different output formats"""
        return {
            OutputFormat.STRUCTURED_TEXT: """
{title}
{separator}

{executive_summary}

{main_content}

{recommendations}

{next_steps}
""",
            OutputFormat.MARKDOWN: """
# {title}

## Executive Summary
{executive_summary}

{main_sections}

## Key Recommendations
{recommendations}

## Next Steps
{next_steps}
""",
            OutputFormat.EXECUTIVE_SUMMARY: """
## Executive Summary

### Key Findings
{key_findings}

### Business Impact
{business_impact}

### Recommendations
{recommendations}

### Timeline
{timeline}
""",
            OutputFormat.TECHNICAL_REPORT: """
# Technical Analysis Report

## Overview
{overview}

## Technical Details
{technical_details}

## Implementation Plan
{implementation}

## Risk Assessment
{risks}

## Recommendations
{recommendations}
"""
        }
    
    def _initialize_terminology_maps(self) -> Dict[DomainType, Dict[str, str]]:
        """Initialize domain-specific terminology mappings"""
        return {
            DomainType.TECHNICAL: {
                "issue": "technical challenge",
                "problem": "system issue",
                "solution": "technical solution",
                "improvement": "optimization",
                "result": "output"
            },
            DomainType.BUSINESS: {
                "issue": "business challenge",
                "problem": "opportunity",
                "solution": "strategic initiative",
                "improvement": "enhancement",
                "result": "outcome"
            },
            DomainType.FINANCIAL: {
                "issue": "financial concern",
                "problem": "risk factor",
                "solution": "financial strategy",
                "improvement": "optimization",
                "result": "financial impact"
            }
        }
    
    def format_answer(self, 
                     holistic_answer: HolisticAnswer,
                     domain_knowledge: EnhancedDomainKnowledge,
                     intent_analysis: DetailedIntentAnalysis,
                     formatting_context: FormattingContext) -> FormattedAnswer:
        """
        Format a holistic answer with domain-specific conventions
        
        Args:
            holistic_answer: The synthesized answer from Phase 3.1
            domain_knowledge: Domain knowledge from Phase 1
            intent_analysis: Intent analysis from Phase 1
            formatting_context: Formatting preferences and context
            
        Returns:
            FormattedAnswer: Domain-formatted answer
        """
        try:
            self.logger.info(f"Formatting answer for domain: {formatting_context.domain.value}")
            
            # Get domain-specific rules
            domain_rules = self.domain_rules.get(formatting_context.domain, 
                                               self.domain_rules[DomainType.GENERAL])
            
            # Apply domain-specific terminology
            formatted_content = self._apply_terminology_mapping(
                holistic_answer, formatting_context.domain)
            
            # Structure content according to domain conventions
            structured_sections = self._structure_content_by_domain(
                formatted_content, domain_rules, formatting_context)
            
            # Apply output format
            final_content = self._apply_output_format(
                structured_sections, formatting_context, domain_rules)
            
            # Generate visualizations if needed
            visualizations = self._generate_visualizations(
                holistic_answer, formatting_context, domain_rules)
            
            # Create formatted answer
            formatted_answer = FormattedAnswer(
                content=final_content,
                format_type=formatting_context.output_format,
                domain=formatting_context.domain,
                style=formatting_context.style,
                sections=structured_sections,
                visualizations=visualizations,
                metadata={
                    "domain_rules_applied": domain_rules.domain.value,
                    "formatting_style": formatting_context.style.value,
                    "target_audience": formatting_context.target_audience,
                    "confidence_score": holistic_answer.confidence_score,
                    "quality_metrics": holistic_answer.quality_metrics
                }
            )
            
            self.logger.info(f"Successfully formatted answer for {formatting_context.domain.value} domain")
            return formatted_answer
            
        except Exception as e:
            self.logger.error(f"Error formatting answer: {str(e)}")
            raise
    
    def _apply_terminology_mapping(self, 
                                  holistic_answer: HolisticAnswer,
                                  domain: DomainType) -> HolisticAnswer:
        """Apply domain-specific terminology mapping"""
        terminology_map = self.terminology_maps.get(domain, {})
        
        if not terminology_map:
            return holistic_answer
        
        # Create a copy to avoid modifying the original
        formatted_answer = HolisticAnswer(
            answer_id=holistic_answer.answer_id,
            query_summary=holistic_answer.query_summary,
            executive_summary=self._replace_terminology(holistic_answer.executive_summary, terminology_map),
            main_sections=[
                AnswerSection(
                    title=section.title,
                    content=self._replace_terminology(section.content, terminology_map),
                    priority=section.priority,
                    section_type=section.section_type,
                    confidence=section.confidence,
                    sources=section.sources,
                    metadata=section.metadata
                )
                for section in holistic_answer.main_sections
            ],
            key_insights=[self._replace_terminology(insight, terminology_map) 
                         for insight in holistic_answer.key_insights],
            recommendations=[self._replace_terminology(rec, terminology_map)
                           for rec in holistic_answer.recommendations],
            next_steps=[self._replace_terminology(step, terminology_map)
                       for step in holistic_answer.next_steps],
            confidence_score=holistic_answer.confidence_score,
            quality_metrics=holistic_answer.quality_metrics,
            synthesis_metadata=holistic_answer.synthesis_metadata,
            generated_at=holistic_answer.generated_at,
            synthesis_time=holistic_answer.synthesis_time
        )
        
        return formatted_answer
    
    def _replace_terminology(self, text: str, terminology_map: Dict[str, str]) -> str:
        """Replace terminology in text according to domain mapping"""
        result = text
        for old_term, new_term in terminology_map.items():
            # Use word boundaries to avoid partial replacements
            pattern = r'\b' + re.escape(old_term) + r'\b'
            result = re.sub(pattern, new_term, result, flags=re.IGNORECASE)
        return result
    
    def _structure_content_by_domain(self, 
                                    holistic_answer: HolisticAnswer,
                                    domain_rules: DomainFormattingRules,
                                    context: FormattingContext) -> List[Dict[str, str]]:
        """Structure content according to domain-specific conventions"""
        structured_sections = []
        
        # Create sections based on domain-specific order
        section_order = domain_rules.section_order or ["summary", "analysis", "recommendations"]
        
        for section_name in section_order:
            section_content = self._generate_section_content(
                section_name, holistic_answer, domain_rules, context)
            
            if section_content:
                structured_sections.append({
                    "title": self._format_section_title(section_name, context),
                    "content": section_content,
                    "type": section_name
                })
        
        return structured_sections
    
    def _generate_section_content(self, 
                                 section_name: str,
                                 holistic_answer: HolisticAnswer,
                                 domain_rules: DomainFormattingRules,
                                 context: FormattingContext) -> str:
        """Generate content for a specific section"""
        content_map = {
            "executive_summary": holistic_answer.executive_summary[:500] + "..." if len(holistic_answer.executive_summary) > 500 else holistic_answer.executive_summary,
            "summary": holistic_answer.executive_summary[:300] + "..." if len(holistic_answer.executive_summary) > 300 else holistic_answer.executive_summary,
            "analysis": self._format_analysis_section(holistic_answer, domain_rules),
            "technical_analysis": self._format_technical_analysis(holistic_answer, domain_rules),
            "business_impact": self._format_business_impact(holistic_answer, domain_rules),
            "financial_analysis": self._format_financial_analysis(holistic_answer, domain_rules),
            "recommendations": self._format_recommendations(holistic_answer, domain_rules),
            "next_steps": self._format_next_steps(holistic_answer, domain_rules),
            "implementation": self._format_implementation(holistic_answer, domain_rules),
            "risks": self._format_risks(holistic_answer, domain_rules),
            "data_overview": self._format_data_overview(holistic_answer, domain_rules),
            "insights": self._format_insights(holistic_answer, domain_rules)
        }
        
        return content_map.get(section_name, "")
    
    def _format_analysis_section(self, 
                                holistic_answer: HolisticAnswer,
                                domain_rules: DomainFormattingRules) -> str:
        """Format the analysis section"""
        sections_content = []
        for section in holistic_answer.main_sections:
            if section.section_type in ["analysis", "findings"]:
                sections_content.append(f"**{section.title}**\n{section.content}")
        
        return "\n\n".join(sections_content)
    
    def _format_technical_analysis(self, 
                                  holistic_answer: HolisticAnswer,
                                  domain_rules: DomainFormattingRules) -> str:
        """Format technical analysis with domain-specific conventions"""
        technical_sections = []
        
        # Add technical details
        for section in holistic_answer.main_sections:
            if any(tech_keyword in section.title.lower() 
                   for tech_keyword in ["technical", "implementation", "architecture", "system"]):
                technical_sections.append(f"### {section.title}\n{section.content}")
        
        # Add code blocks or technical diagrams if conventions require
        if domain_rules.formatting_conventions.get("code_blocks", False):
            technical_sections.append("### Implementation Details\n```\n# Technical implementation details\n```")
        
        return "\n\n".join(technical_sections)
    
    def _format_business_impact(self, 
                               holistic_answer: HolisticAnswer,
                               domain_rules: DomainFormattingRules) -> str:
        """Format business impact section"""
        business_content = []
        
        # Extract business-related insights
        business_insights = [insight for insight in holistic_answer.key_insights 
                           if any(biz_keyword in insight.lower() 
                                  for biz_keyword in ["business", "revenue", "cost", "efficiency", "roi"])]
        
        if business_insights:
            business_content.append("**Key Business Insights:**")
            for insight in business_insights:
                business_content.append(f"• {insight}")
        
        # Add ROI calculations if required
        if domain_rules.formatting_conventions.get("roi_calculations", False):
            business_content.append("\n**ROI Analysis:**")
            business_content.append("• Expected return on investment: TBD")
            business_content.append("• Implementation cost: TBD")
            business_content.append("• Time to value: TBD")
        
        return "\n".join(business_content)
    
    def _format_financial_analysis(self, 
                                  holistic_answer: HolisticAnswer,
                                  domain_rules: DomainFormattingRules) -> str:
        """Format financial analysis section"""
        financial_content = []
        
        # Add financial tables if required
        if domain_rules.formatting_conventions.get("financial_tables", False):
            financial_content.append("**Financial Overview:**")
            financial_content.append("| Metric | Value | Impact |")
            financial_content.append("|--------|-------|---------|")
            financial_content.append("| Revenue Impact | TBD | Positive |")
            financial_content.append("| Cost Savings | TBD | Positive |")
            financial_content.append("| Implementation Cost | TBD | One-time |")
        
        return "\n".join(financial_content)
    
    def _format_recommendations(self, 
                               holistic_answer: HolisticAnswer,
                               domain_rules: DomainFormattingRules) -> str:
        """Format recommendations section"""
        recommendations = []
        
        for i, rec in enumerate(holistic_answer.recommendations, 1):
            recommendations.append(f"{i}. {rec}")
        
        return "\n".join(recommendations)
    
    def _format_next_steps(self, 
                          holistic_answer: HolisticAnswer,
                          domain_rules: DomainFormattingRules) -> str:
        """Format next steps section"""
        next_steps = []
        
        # Add timeline emphasis if required
        if domain_rules.formatting_conventions.get("timeline_emphasis", False):
            next_steps.append("**Immediate Actions (Week 1):**")
            
        for i, step in enumerate(holistic_answer.next_steps, 1):
            next_steps.append(f"{i}. {step}")
        
        return "\n".join(next_steps)
    
    def _format_implementation(self, 
                              holistic_answer: HolisticAnswer,
                              domain_rules: DomainFormattingRules) -> str:
        """Format implementation section"""
        implementation_content = []
        
        # Add step-by-step if required
        if domain_rules.formatting_conventions.get("step_by_step", False):
            implementation_content.append("**Implementation Steps:**")
            for i, step in enumerate(holistic_answer.next_steps, 1):
                implementation_content.append(f"Step {i}: {step}")
        
        return "\n".join(implementation_content)
    
    def _format_risks(self, 
                     holistic_answer: HolisticAnswer,
                     domain_rules: DomainFormattingRules) -> str:
        """Format risks section"""
        risks_content = []
        
        # Add risk assessment if required
        if domain_rules.formatting_conventions.get("risk_assessment", False):
            risks_content.append("**Risk Assessment:**")
            risks_content.append("• Implementation risks: Medium")
            risks_content.append("• Technical risks: Low")
            risks_content.append("• Business risks: Low")
        
        return "\n".join(risks_content)
    
    def _format_data_overview(self, 
                             holistic_answer: HolisticAnswer,
                             domain_rules: DomainFormattingRules) -> str:
        """Format data overview section for analytics domain"""
        data_content = []
        
        # Add data tables if required
        if domain_rules.formatting_conventions.get("data_tables", False):
            data_content.append("**Data Summary:**")
            data_content.append("| Metric | Value |")
            data_content.append("|--------|-------|")
            data_content.append("| Records Analyzed | TBD |")
            data_content.append("| Data Quality | TBD |")
            data_content.append("| Coverage | TBD |")
        
        return "\n".join(data_content)
    
    def _format_insights(self, 
                        holistic_answer: HolisticAnswer,
                        domain_rules: DomainFormattingRules) -> str:
        """Format insights section"""
        insights_content = []
        
        insights_content.append("**Key Insights:**")
        for insight in holistic_answer.key_insights:
            insights_content.append(f"• {insight}")
        
        return "\n".join(insights_content)
    
    def _format_section_title(self, section_name: str, context: FormattingContext) -> str:
        """Format section title according to style"""
        title_map = {
            "executive_summary": "Executive Summary",
            "technical_analysis": "Technical Analysis",
            "business_impact": "Business Impact",
            "financial_analysis": "Financial Analysis",
            "recommendations": "Recommendations",
            "next_steps": "Next Steps",
            "implementation": "Implementation Plan",
            "risks": "Risk Assessment",
            "data_overview": "Data Overview",
            "insights": "Key Insights"
        }
        
        return title_map.get(section_name, section_name.title().replace("_", " "))
    
    def _apply_output_format(self, 
                            sections: List[Dict[str, str]],
                            context: FormattingContext,
                            domain_rules: DomainFormattingRules) -> str:
        """Apply the specified output format to the structured content"""
        template = self.formatting_templates.get(context.output_format, 
                                                self.formatting_templates[OutputFormat.STRUCTURED_TEXT])
        
        # Prepare content for template
        title = f"Domain Analysis Report - {context.domain.value.title()}"
        separator = "=" * len(title)
        
        # Extract specific sections
        executive_summary = next((s["content"] for s in sections if s["type"] == "executive_summary"), "")
        recommendations = next((s["content"] for s in sections if s["type"] == "recommendations"), "")
        next_steps = next((s["content"] for s in sections if s["type"] == "next_steps"), "")
        
        # Create main content
        main_sections = []
        for section in sections:
            if section["type"] not in ["executive_summary", "recommendations", "next_steps"]:
                if context.output_format == OutputFormat.MARKDOWN:
                    main_sections.append(f"## {section['title']}\n{section['content']}")
                else:
                    main_sections.append(f"{section['title']}\n{'-' * len(section['title'])}\n{section['content']}")
        
        main_content = "\n\n".join(main_sections)
        
        # Apply template
        formatted_content = template.format(
            title=title,
            separator=separator,
            executive_summary=executive_summary,
            main_content=main_content,
            main_sections=main_content,
            recommendations=recommendations,
            next_steps=next_steps,
            key_findings=executive_summary,
            business_impact=next((s["content"] for s in sections if s["type"] == "business_impact"), ""),
            timeline=next_steps,
            overview=executive_summary,
            technical_details=next((s["content"] for s in sections if s["type"] == "technical_analysis"), ""),
            implementation=next((s["content"] for s in sections if s["type"] == "implementation"), ""),
            risks=next((s["content"] for s in sections if s["type"] == "risks"), "")
        )
        
        return formatted_content
    
    def _generate_visualizations(self, 
                               holistic_answer: HolisticAnswer,
                               context: FormattingContext,
                               domain_rules: DomainFormattingRules) -> List[Dict[str, Any]]:
        """Generate visualization specifications based on domain preferences"""
        visualizations = []
        
        if not context.include_visualizations:
            return visualizations
        
        # Generate visualizations based on domain preferences
        for viz_type in domain_rules.visualization_preferences:
            visualization = {
                "type": viz_type,
                "title": f"{viz_type.title().replace('_', ' ')} for {context.domain.value.title()}",
                "description": f"Visualization showing {viz_type} analysis",
                "data_source": "holistic_answer_analysis",
                "format": "placeholder"  # In real implementation, this would contain actual visualization data
            }
            visualizations.append(visualization)
        
        return visualizations
    
    def create_formatting_context(self, 
                                 domain_knowledge: EnhancedDomainKnowledge,
                                 intent_analysis: DetailedIntentAnalysis,
                                 user_preferences: Optional[Dict[str, Any]] = None) -> FormattingContext:
        """
        Create formatting context based on domain knowledge and intent analysis
        
        Args:
            domain_knowledge: Domain knowledge from Phase 1
            intent_analysis: Intent analysis from Phase 1
            user_preferences: Optional user preferences
            
        Returns:
            FormattingContext: Context for formatting
        """
        # Determine domain type
        domain_type = self._determine_domain_type(domain_knowledge)
        
        # Determine output format based on intent
        output_format = self._determine_output_format(intent_analysis)
        
        # Determine formatting style
        style = self._determine_formatting_style(intent_analysis, user_preferences)
        
        # Determine target audience
        target_audience = self._determine_target_audience(intent_analysis)
        
        return FormattingContext(
            domain=domain_type,
            output_format=output_format,
            style=style,
            target_audience=target_audience,
            use_technical_terms=domain_type in [DomainType.TECHNICAL, DomainType.SCIENTIFIC],
            include_visualizations=True,
            priority_sections=self._determine_priority_sections(intent_analysis)
        )
    
    def _determine_domain_type(self, domain_knowledge: EnhancedDomainKnowledge) -> DomainType:
        """Determine domain type from domain knowledge"""
        domain_name = domain_knowledge.taxonomy.primary_domain.value.lower()
        
        domain_mapping = {
            "technical": DomainType.TECHNICAL,
            "technology": DomainType.TECHNICAL,
            "engineering": DomainType.TECHNICAL,
            "software": DomainType.TECHNICAL,
            "business": DomainType.BUSINESS,
            "finance": DomainType.FINANCIAL,
            "financial": DomainType.FINANCIAL,
            "marketing": DomainType.MARKETING,
            "science": DomainType.SCIENTIFIC,
            "research": DomainType.SCIENTIFIC,
            "analytics": DomainType.ANALYTICS,
            "data": DomainType.ANALYTICS,
            "operations": DomainType.OPERATIONS,
            "medical": DomainType.MEDICAL,
            "healthcare": DomainType.MEDICAL,
            "legal": DomainType.LEGAL,
            "education": DomainType.EDUCATIONAL,
            "manufacturing": DomainType.TECHNICAL,
            "general": DomainType.GENERAL,
            "retail": DomainType.BUSINESS,
            "logistics": DomainType.OPERATIONS,
            "energy": DomainType.TECHNICAL,
            "mixed": DomainType.GENERAL
        }
        
        for keyword, domain_type in domain_mapping.items():
            if keyword in domain_name:
                return domain_type
        
        return DomainType.GENERAL
    
    def _determine_output_format(self, intent_analysis: DetailedIntentAnalysis) -> OutputFormat:
        """Determine output format based on intent analysis"""
        intent_keywords = intent_analysis.primary_intent.lower()
        
        if "summary" in intent_keywords:
            return OutputFormat.EXECUTIVE_SUMMARY
        elif "technical" in intent_keywords:
            return OutputFormat.TECHNICAL_REPORT
        elif "report" in intent_keywords:
            return OutputFormat.STRUCTURED_TEXT
        elif "presentation" in intent_keywords:
            return OutputFormat.PRESENTATION
        elif "dashboard" in intent_keywords:
            return OutputFormat.DASHBOARD
        else:
            return OutputFormat.STRUCTURED_TEXT
    
    def _determine_formatting_style(self, 
                                   intent_analysis: DetailedIntentAnalysis,
                                   user_preferences: Optional[Dict[str, Any]]) -> FormattingStyle:
        """Determine formatting style"""
        if user_preferences and "style" in user_preferences:
            style_name = user_preferences["style"].lower()
            for style in FormattingStyle:
                if style.value == style_name:
                    return style
        
        # Default based on intent
        if "executive" in intent_analysis.primary_intent.lower():
            return FormattingStyle.EXECUTIVE
        elif "technical" in intent_analysis.primary_intent.lower():
            return FormattingStyle.TECHNICAL
        else:
            return FormattingStyle.FORMAL
    
    def _determine_target_audience(self, intent_analysis: DetailedIntentAnalysis) -> str:
        """Determine target audience from intent analysis"""
        if "executive" in intent_analysis.primary_intent.lower():
            return "executives"
        elif "technical" in intent_analysis.primary_intent.lower():
            return "technical_team"
        elif "business" in intent_analysis.primary_intent.lower():
            return "business_analysts"
        else:
            return "general"
    
    def _determine_priority_sections(self, intent_analysis: DetailedIntentAnalysis) -> List[str]:
        """Determine priority sections based on intent"""
        priority_sections = []
        
        if "recommendation" in intent_analysis.primary_intent.lower():
            priority_sections.append("recommendations")
        if "analysis" in intent_analysis.primary_intent.lower():
            priority_sections.append("analysis")
        if "implementation" in intent_analysis.primary_intent.lower():
            priority_sections.append("implementation")
        
        return priority_sections
    
    def get_supported_domains(self) -> List[DomainType]:
        """Get list of supported domain types"""
        return list(DomainType)
    
    def get_supported_formats(self) -> List[OutputFormat]:
        """Get list of supported output formats"""
        return list(OutputFormat)
    
    def get_domain_rules(self, domain: DomainType) -> DomainFormattingRules:
        """Get formatting rules for a specific domain"""
        return self.domain_rules.get(domain, self.domain_rules[DomainType.GENERAL])
    
    def validate_formatting_context(self, context: FormattingContext) -> bool:
        """Validate formatting context"""
        return (
            context.domain in DomainType and
            context.output_format in OutputFormat and
            context.style in FormattingStyle and
            context.target_audience is not None
        ) 