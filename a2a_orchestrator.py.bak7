#!/usr/bin/env python3
"""
A2A Orchestrator - AI Data Science Team Multi-Agent Coordinator
A2A SDK 0.2.9 ì™„ì „ í‘œì¤€ ì¤€ìˆ˜ ë²„ì „

í•µì‹¬ ê¸°ëŠ¥:
1. Dynamic Agent Discovery: ì‚¬ìš© ê°€ëŠ¥í•œ A2A ì—ì´ì „íŠ¸ ìë™ ë°œê²¬
2. LLM-driven Planning: GPT-4oë¥¼ í™œìš©í•œ ì§€ëŠ¥í˜• ì›Œí¬í”Œë¡œìš° ê³„íš ìˆ˜ë¦½
3. Multi-Agent Execution: ë³‘ë ¬/ìˆœì°¨ ì—ì´ì „íŠ¸ ì‹¤í–‰ ì¡°ì •
4. Error Recovery: ì‹¤íŒ¨í•œ ë‹¨ê³„ì— ëŒ€í•œ ìë™ ë³µêµ¬ ë©”ì»¤ë‹ˆì¦˜

A2A SDK 0.2.9 í‘œì¤€ ì¤€ìˆ˜ ì‚¬í•­:
- A2AStarletteApplicationê³¼ DefaultRequestHandler ì‚¬ìš©
- AgentExecutor ìƒì†í•˜ì—¬ execute()ì™€ cancel() ë©”ì„œë“œ êµ¬í˜„
- RequestContextì™€ TaskStore í™œìš©
- /.well-known/agent.jsonì—ì„œ í‘œì¤€ Agent Card ì œê³µ
- A2AClientë¡œ í‘œì¤€ ë©”ì‹œì§€ í†µì‹ 
"""

import asyncio
import json
import logging
import os
import sys
import time
from typing import Any, Dict, List, Optional

import httpx
import uvicorn
from openai import AsyncOpenAI

# A2A SDK 0.2.9 í‘œì¤€ ì„í¬íŠ¸
from a2a.server.apps import A2AStarletteApplication
from a2a.server.request_handlers import DefaultRequestHandler
from a2a.server.tasks import InMemoryTaskStore
from a2a.server.agent_execution import AgentExecutor, RequestContext
from a2a.server.events import EventQueue
from a2a.types import (
    AgentCard,
    AgentSkill,
    AgentCapabilities,
    TaskState,
    TextPart,
    Part,
    Message,
    Role
)

# ë¡œê¹… ì„¤ì •
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# OpenAI í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™”
openai_client = AsyncOpenAI()

# AI DS Team ì—ì´ì „íŠ¸ í¬íŠ¸ ë§¤í•‘
AGENT_PORTS = {
    "data_cleaning": 8306,
    "data_loader": 8307,
    "data_visualization": 8308,
    "data_wrangling": 8309,
    "feature_engineering": 8310,
    "sql_database": 8311,
    "eda_tools": 8312,
    "h2o_ml": 8313,
    "mlflow_tools": 8314,
}


class A2AOrchestratorExecutor(AgentExecutor):
    """A2A SDK 0.2.9 í‘œì¤€ ì¤€ìˆ˜ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° ì‹¤í–‰ì"""
    
    def __init__(self):
        self.openai_client = openai_client
    
    async def execute(
        self,
        context: RequestContext,
        event_queue: EventQueue,
    ) -> None:
        """A2A ìš”ì²­ ì‹¤í–‰ - A2A SDK 0.2.9 í‘œì¤€ íŒ¨í„´"""
        
        logger.info("ğŸ¬ A2A Orchestrator Executor starting...")
        
        try:
            # ì‚¬ìš©ì ë©”ì‹œì§€ ì¶”ì¶œ (A2A SDK 0.2.9 í‘œì¤€ ë°©ì‹)
            user_message = ""
            if context.message and context.message.parts:
                for part in context.message.parts:
                    if hasattr(part, 'text'):
                        user_message += part.text + " "
                    elif hasattr(part, 'root') and hasattr(part.root, 'text'):
                        user_message += part.root.text + " "
            
            user_message = user_message.strip()
            logger.info(f"ğŸ“ Extracted user message: '{user_message}'")
            
            if not user_message:
                # ì—ëŸ¬ ë©”ì‹œì§€ ì „ì†¡
                error_msg = Message(
                    messageId=f"error-{int(time.time())}",
                    role=Role.agent,
                    parts=[Part(TextPart(text="âŒ ìš”ì²­ ë©”ì‹œì§€ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤."))]
                )
                await event_queue.enqueue_event(error_msg)
                return
            
            # ì§„í–‰ ìƒí™© ì—…ë°ì´íŠ¸
            progress_msg = Message(
                messageId=f"progress-{int(time.time())}",
                role=Role.agent,
                parts=[Part(TextPart(text="ğŸ” AI DS Team ì—ì´ì „íŠ¸ë“¤ì„ ë°œê²¬í•˜ê³  ìˆìŠµë‹ˆë‹¤..."))]
            )
            await event_queue.enqueue_event(progress_msg)
            
            # ì—ì´ì „íŠ¸ ë°œê²¬
            available_agents = await self._discover_agents()
            
            if not available_agents:
                error_msg = Message(
                    messageId=f"error-{int(time.time())}",
                    role=Role.agent,
                    parts=[Part(TextPart(text="âŒ ì‚¬ìš© ê°€ëŠ¥í•œ A2A ì—ì´ì „íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."))]
                )
                await event_queue.enqueue_event(error_msg)
                return
            
            # ê³„íš ìˆ˜ë¦½
            plan_msg = Message(
                messageId=f"planning-{int(time.time())}",
                role=Role.agent,
                parts=[Part(TextPart(text="ğŸ§  ì§€ëŠ¥í˜• ë¶„ì„ ê³„íšì„ ìˆ˜ë¦½í•˜ê³  ìˆìŠµë‹ˆë‹¤..."))]
            )
            await event_queue.enqueue_event(plan_msg)
            
            plan = await self._create_plan(user_message, available_agents)
            
            # ê³„íš ì‹¤í–‰
            exec_msg = Message(
                messageId=f"execution-{int(time.time())}",
                role=Role.agent,
                parts=[Part(TextPart(text="âš¡ ê³„íšì„ ì‹¤í–‰í•˜ê³  ìˆìŠµë‹ˆë‹¤..."))]
            )
            await event_queue.enqueue_event(exec_msg)
            
            results = await self._execute_plan(plan, available_agents)
            
            # ê²°ê³¼ í¬ë§·íŒ… ë° ì „ì†¡
            response_text = self._format_results(results, plan)
            
            final_msg = Message(
                messageId=f"result-{int(time.time())}",
                role=Role.agent,
                parts=[Part(TextPart(text=response_text))]
            )
            await event_queue.enqueue_event(final_msg)
            
            logger.info("âœ… A2A Orchestrator execution completed")
            
        except Exception as e:
            logger.error(f"âŒ A2A Orchestrator execution failed: {e}", exc_info=True)
            error_msg = Message(
                messageId=f"error-{int(time.time())}",
                role=Role.agent,
                parts=[Part(TextPart(text=f"âŒ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {str(e)}"))]
            )
            await event_queue.enqueue_event(error_msg)

    async def cancel(
        self, context: RequestContext, event_queue: EventQueue
    ) -> None:
        """ì‘ì—… ì·¨ì†Œ"""
        logger.info(f"ğŸ›‘ Orchestrator operation cancelled for context {context.context_id}")
        cancel_msg = Message(
            messageId=f"cancel-{int(time.time())}",
            role=Role.agent,
            parts=[Part(TextPart(text="ğŸ›‘ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤."))]
        )
        await event_queue.enqueue_event(cancel_msg)

    async def _discover_agents(self) -> Dict[str, Dict[str, Any]]:
        """ì—ì´ì „íŠ¸ ë°œê²¬"""
        available_agents = {}
        
        async with httpx.AsyncClient(timeout=5.0) as client:
            for agent_name, port in AGENT_PORTS.items():
                try:
                    response = await client.get(f"http://localhost:{port}/.well-known/agent.json")
                    if response.status_code == 200:
                        agent_card = response.json()
                        available_agents[agent_name] = {
                            "name": agent_card.get("name", agent_name),
                            "url": f"http://localhost:{port}",
                            "port": port,
                            "description": agent_card.get("description", ""),
                            "status": "available"
                        }
                        logger.info(f"âœ… {agent_name} agent discovered on port {port}")
                except Exception as e:
                    logger.warning(f"âš ï¸ {agent_name} agent on port {port} not available: {e}")
        
        logger.info(f"ğŸ” Total discovered agents: {len(available_agents)}")
        return available_agents

    async def _create_plan(self, user_query: str, available_agents: Dict[str, Dict[str, Any]]) -> Dict[str, Any]:
        """ì§€ëŠ¥ì  ê³„íš ìˆ˜ë¦½ - ì¢…í•© ë¶„ì„ ë° ìµœì¢… ë³´ê³ ì„œ ìƒì„±ì„ ìœ„í•œ ë‹¤ë‹¨ê³„ ê³„íš"""
        try:
            if not available_agents:
                return {"steps": []}
            
            # "ì¢…í•© ë¶„ì„" í‚¤ì›Œë“œ ê°ì§€
            is_comprehensive_analysis = any(keyword in user_query.lower() for keyword in 
                                          ['ì¢…í•©', 'comprehensive', 'ë¶„ì„', 'ë³´ê³ ì„œ', 'report', 'ì „ì²´'])
            
            if is_comprehensive_analysis:
                # ì¢…í•© ë¶„ì„ì„ ìœ„í•œ ë‹¤ë‹¨ê³„ ê³„íš
                steps = []
                step_num = 1
                
                # 1ë‹¨ê³„: ë°ì´í„° ë¡œë”© (data_loaderê°€ ìˆìœ¼ë©´)
                if "data_loader" in available_agents:
                    steps.append({
                        "step": step_num,
                        "agent": "data_loader",
                        "task_description": "ë°ì´í„°ë¥¼ ë¡œë“œí•˜ê³  ê¸°ë³¸ êµ¬ì¡°ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”",
                        "expected_outcome": "ë°ì´í„° ë¡œë”© ë° ê¸°ë³¸ ì •ë³´"
                    })
                    step_num += 1
                
                # 2ë‹¨ê³„: íƒìƒ‰ì  ë°ì´í„° ë¶„ì„ (eda_tools)
                if "eda_tools" in available_agents:
                    steps.append({
                        "step": step_num,
                        "agent": "eda_tools", 
                        "task_description": "íƒìƒ‰ì  ë°ì´í„° ë¶„ì„ì„ ìˆ˜í–‰í•˜ì—¬ ë°ì´í„°ì˜ íŠ¹ì„±, ë¶„í¬, ìƒê´€ê´€ê³„ë¥¼ ë¶„ì„í•´ì£¼ì„¸ìš”",
                        "expected_outcome": "EDA ë¶„ì„ ê²°ê³¼"
                    })
                    step_num += 1
                
                # 3ë‹¨ê³„: ë°ì´í„° ì‹œê°í™” (data_visualization)
                if "data_visualization" in available_agents:
                    steps.append({
                        "step": step_num,
                        "agent": "data_visualization",
                        "task_description": "ë°ì´í„°ì˜ ì£¼ìš” íŒ¨í„´ê³¼ ì¸ì‚¬ì´íŠ¸ë¥¼ ì‹œê°í™”í•´ì£¼ì„¸ìš”",
                        "expected_outcome": "ë°ì´í„° ì‹œê°í™” ì°¨íŠ¸"
                    })
                    step_num += 1
                
                # 4ë‹¨ê³„: ë°ì´í„° í’ˆì§ˆ ê²€ì‚¬ (data_cleaning)
                if "data_cleaning" in available_agents:
                    steps.append({
                        "step": step_num,
                        "agent": "data_cleaning",
                        "task_description": "ë°ì´í„° í’ˆì§ˆì„ ê²€ì‚¬í•˜ê³  ì´ìƒì¹˜ë‚˜ ê²°ì¸¡ê°’ì„ í™•ì¸í•´ì£¼ì„¸ìš”",
                        "expected_outcome": "ë°ì´í„° í’ˆì§ˆ ë³´ê³ ì„œ"
                    })
                    step_num += 1
                
                # ê³„íšì´ ì—†ìœ¼ë©´ ì²« ë²ˆì§¸ ì‚¬ìš© ê°€ëŠ¥í•œ ì—ì´ì „íŠ¸ë¼ë„ ì‚¬ìš©
                if not steps and available_agents:
                    first_agent = list(available_agents.keys())[0]
                    steps.append({
                        "step": 1,
                        "agent": first_agent,
                        "task_description": user_query,
                        "expected_outcome": "ë¶„ì„ ê²°ê³¼"
                    })
                
                return {
                    "objective": "ì¢…í•©ì  ë°ì´í„° ë¶„ì„ ë° ë³´ê³ ì„œ ìƒì„±",
                    "steps": steps,
                    "plan_type": "comprehensive_analysis"
                }
            
            else:
                # ì¼ë°˜ì ì¸ ë‹¨ì¼ ì—ì´ì „íŠ¸ ìš”ì²­
                # ìš”ì²­ ë‚´ìš©ì— ë”°ë¼ ê°€ì¥ ì í•©í•œ ì—ì´ì „íŠ¸ ì„ íƒ
                if "ì‹œê°í™”" in user_query and "data_visualization" in available_agents:
                    agent = "data_visualization"
                elif "eda" in user_query.lower() or "íƒìƒ‰" in user_query and "eda_tools" in available_agents:
                    agent = "eda_tools"
                elif "ì •ë¦¬" in user_query or "clean" in user_query.lower() and "data_cleaning" in available_agents:
                    agent = "data_cleaning"
                else:
                    # ê¸°ë³¸ì ìœ¼ë¡œ ì²« ë²ˆì§¸ ì—ì´ì „íŠ¸
                    agent = list(available_agents.keys())[0]
                
                return {
                    "objective": "ë‹¨ì¼ ì—ì´ì „íŠ¸ ì‘ì—… ìˆ˜í–‰",
                    "steps": [
                        {
                            "step": 1,
                            "agent": agent,
                            "task_description": user_query,
                            "expected_outcome": "ë¶„ì„ ê²°ê³¼"
                        }
                    ],
                    "plan_type": "single_agent"
                }
            
        except Exception as e:
            logger.error(f"âŒ Plan creation failed: {e}")
            return {"steps": []}

    async def _execute_plan(self, plan: Dict[str, Any], available_agents: Dict[str, Dict[str, Any]]) -> List[Dict[str, Any]]:
        """ê³„íš ì‹¤í–‰"""
        results = []
        
        for step in plan.get("steps", []):
            agent_name = step["agent"]
            if agent_name in available_agents:
                agent_info = available_agents[agent_name]
                result = await self._execute_step(step, agent_info)
                results.append(result)
        
        return results

    async def _execute_step(self, step: Dict[str, Any], agent_info: Dict[str, Any]) -> Dict[str, Any]:
        """ë‹¨ê³„ ì‹¤í–‰"""
        try:
            message_payload = {
                "jsonrpc": "2.0",
                "id": f"orchestrator-step-{step['step']}",
                "method": "message/send",
                "params": {
                    "message": {
                        "role": "user",
                        "parts": [{"kind": "text", "text": step["task_description"]}],
                        "messageId": f"step-{step['step']}-{int(time.time())}"
                    }
                }
            }
            
            async with httpx.AsyncClient(timeout=60.0) as client:
                response = await client.post(
                    agent_info["url"],
                    json=message_payload,
                    headers={"Content-Type": "application/json"}
                )
                
                if response.status_code == 200:
                    result = response.json()
                    return {
                        "step": step["step"],
                        "agent": step["agent"],
                        "status": "success",
                        "result": result
                    }
                else:
                    return {
                        "step": step["step"],
                        "agent": step["agent"],
                        "status": "failed",
                        "error": f"HTTP {response.status_code}"
                    }
                    
        except Exception as e:
            return {
                "step": step["step"],
                "agent": step["agent"],
                "status": "error",
                "error": str(e)
            }

    def _format_results(self, results: List[Dict[str, Any]], plan: Dict[str, Any]) -> str:
        """ê²°ê³¼ í¬ë§·íŒ…"""
        successful = [r for r in results if r["status"] == "success"]
        failed = [r for r in results if r["status"] != "success"]
        
        response = f"""âœ… **ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜ ì™„ë£Œ**

ğŸ“‹ **ëª©í‘œ**: {plan.get('objective', 'ë°ì´í„° ë¶„ì„')}
ğŸ¯ **ì„±ê³µí•œ ë‹¨ê³„**: {len(successful)}/{len(results)}

ğŸ“Š **ë‹¨ê³„ë³„ ê²°ê³¼**:
"""
        
        for result in results:
            status_emoji = "âœ…" if result["status"] == "success" else "âŒ"
            response += f"{status_emoji} Step {result['step']}: {result['agent']}\n"
        
        return response


def create_orchestrator_server():
    """A2A SDK 0.2.9 í‘œì¤€ ì¤€ìˆ˜ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° ì„œë²„ ìƒì„±"""
    
    # Agent Card ì •ì˜
    agent_card = AgentCard(
        name="AI DS Team Orchestrator",
        description="AI Data Science Teamì˜ ë©€í‹° ì—ì´ì „íŠ¸ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°",
        url="http://localhost:8100",
        version="3.0.0",
        capabilities=AgentCapabilities(
            streaming=True,
            pushNotifications=False,
            stateTransitionHistory=True
        ),
        defaultInputModes=["text/plain"],
        defaultOutputModes=["text/plain"],
        skills=[
            AgentSkill(
                id="orchestrate_analysis",
                name="AI DS Team Orchestration",
                description="AI Data Science Team ì—ì´ì „íŠ¸ë“¤ì„ ì¡°ì •í•˜ì—¬ ë°ì´í„° ë¶„ì„ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.",
                tags=["orchestration", "multi-agent", "data-science"]
            )
        ]
    )
    
    # A2A SDK 0.2.9 í‘œì¤€ êµ¬ì„±ìš”ì†Œ ì‚¬ìš©
    executor = A2AOrchestratorExecutor()
    task_store = InMemoryTaskStore()
    request_handler = DefaultRequestHandler(
        agent_executor=executor,
        task_store=task_store
    )
    
    # A2A Starlette Application ìƒì„±
    app = A2AStarletteApplication(
        agent_card=agent_card,
        http_handler=request_handler
    )
    
    return app


def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜"""
    logger.info("ğŸš€ Starting A2A Orchestrator Server (A2A SDK 0.2.9 Standard)")
    
    # ì„œë²„ ìƒì„± ë° ì‹¤í–‰
    app = create_orchestrator_server()
    
    # Uvicornìœ¼ë¡œ ì„œë²„ ì‹¤í–‰
    uvicorn.run(
        app.build(),
        host="localhost",
        port=8100,
        log_level="info"
    )


if __name__ == "__main__":
    main() 