# A2A Data Science Servers - Regex Utilities
# Enhanced regex utilities for A2A protocol

import re
from datetime import datetime
from typing import List, Any

def relocate_imports_inside_function(code_text: str) -> str:
    """
    Relocates all import statements in a given Python function and moves them inside the function definition.
    Enhanced version with better error handling.

    Parameters
    ----------
    code_text : str
        The Python code as a string.

    Returns
    -------
    str
        The modified Python code with imports relocated inside the function.
    """
    if not code_text or not isinstance(code_text, str):
        return code_text
        
    # Match all import statements
    import_pattern = r'^\s*(import\s+[^\n]+|from\s+\S+\s+import\s+[^\n]+)\s*$'
    imports = re.findall(import_pattern, code_text, re.MULTILINE)

    # Remove imports from the top-level code
    code_without_imports = re.sub(import_pattern, '', code_text, flags=re.MULTILINE).strip()

    # Find the function definition and insert the imports inside it
    function_pattern = r'(def\s+\w+\s*\(.*?\):)'
    match = re.search(function_pattern, code_without_imports)

    if match and imports:
        function_start = match.end()
        # Insert the imports right after the function definition
        imports_code = '\n    ' + '\n    '.join(imports)  # Indent imports
        modified_code = (
            code_without_imports[:function_start]
            + imports_code
            + code_without_imports[function_start:]
        )
        return modified_code

    # If no function is found, return the original code
    return code_text

def add_comments_to_top(code_text: str, agent_name: str = "data_wrangler", a2a_context: bool = True) -> str:
    """
    Adds AI-generated metadata comments to the top of the Python code.
    Enhanced version with A2A protocol information.

    Parameters
    ----------
    code_text : str
        The Python code to be commented.
    agent_name : str, optional
        The agent name to include in the comments, by default "data_wrangler".
    a2a_context : bool, optional
        Whether to include A2A protocol context, by default True.

    Returns
    -------
    str
        The Python code with the added comments at the top.
    """
    if not code_text:
        return code_text
        
    # Generate timestamp
    time_created = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    # Construct the header comments
    header_comments = [
        "# Disclaimer: This function was generated by AI. Please review before using.",
        f"# Agent Name: {agent_name}",
        f"# Time Created: {time_created}",
    ]
    
    if a2a_context:
        header_comments.extend([
            "# Generated via A2A Protocol",
            "# Compatible with Streamlit Dashboard",
        ])
    
    header_comments.extend(["", ""])

    # Join the header with newlines, then prepend to the existing code_text
    header_block = "\n".join(header_comments)
    return header_block + code_text

def format_agent_name(agent_name: str) -> str:
    """
    Format agent name for display with enhanced styling.
    
    Parameters
    ----------
    agent_name : str
        The agent name to format.
        
    Returns
    -------
    str
        Formatted agent name.
    """
    if not agent_name:
        return "---UNKNOWN AGENT---"
        
    formatted_name = agent_name.strip().replace("_", " ").upper()
    return f"🤖 {formatted_name} 🤖"

def format_recommended_steps(raw_text: str, heading: str = "# Recommended Steps:") -> str:
    """
    Format recommended steps with enhanced structure.
    
    Parameters
    ----------
    raw_text : str
        Raw text to format.
    heading : str, optional
        Heading to use, by default "# Recommended Steps:".
        
    Returns
    -------
    str
        Formatted text with proper heading.
    """
    if not raw_text:
        return heading + "\n\n*No steps provided*"
        
    # Split text by newline and strip leading/trailing whitespace
    lines = raw_text.strip().split('\n')
    
    # Remove empty lines from the start
    while lines and not lines[0].strip():
        lines.pop(0)

    seen_heading = False
    new_lines = []

    for line in lines:
        # If this line *is exactly* the heading, check if we've seen it already
        if line.strip() == heading:
            if seen_heading:
                # Skip duplicates
                continue
            else:
                seen_heading = True
        new_lines.append(line)

    # If heading was never seen, prepend it
    if not seen_heading:
        new_lines.insert(0, heading)

    return "\n".join(new_lines)

def get_generic_summary(report_dict: dict, code_lang: str = "python") -> str:
    """
    Takes a dictionary of unknown structure and returns a textual summary.
    Enhanced version with better formatting for A2A protocol.

    Parameters
    ----------
    report_dict : dict
        The dictionary holding the agent output or user report.
    code_lang : str, optional
        Code language for syntax highlighting, by default "python".

    Returns
    -------
    str
        A formatted summary string with enhanced styling.
    """
    if not report_dict or not isinstance(report_dict, dict):
        return "# Empty Report\n\n*No data provided*"
        
    # 1) Grab the report title (or default)
    title = report_dict.get("report_title", "Agent Analysis Report")

    lines = []
    lines.append(f"# 📊 {title}")
    lines.append("---")

    # 2) Iterate over all other keys
    for key, value in report_dict.items():
        # Skip the title key, since we already displayed it
        if key == "report_title":
            continue

        # 3) Check if it's code or function
        key_lower = key.lower()
        if "code" in key_lower or "function" in key_lower:
            # Treat as code
            lines.append(f"\n## 🔧 {format_key_name(key)}")
            lines.append(f"```{code_lang}\n{str(value)}\n```")
        elif "error" in key_lower:
            # Treat as error
            lines.append(f"\n## ⚠️ {format_key_name(key)}")
            lines.append(f"```\n{str(value)}\n```")
        elif "data" in key_lower:
            # Treat as data
            lines.append(f"\n## 📈 {format_key_name(key)}")
            lines.append(str(value))
        else:
            # 4) Otherwise, just display the key-value as text
            lines.append(f"\n## 📝 {format_key_name(key)}")
            lines.append(str(value))

    return "\n".join(lines)

def format_key_name(key: str) -> str:
    """
    Format dictionary key names for better display.
    
    Parameters
    ----------
    key : str
        The key to format.
        
    Returns
    -------
    str
        Formatted key name.
    """
    if not key:
        return "Unknown"
        
    # Replace underscores with spaces and capitalize
    formatted = key.replace("_", " ").title()
    return formatted

def remove_consecutive_duplicates(messages: List[Any]) -> List[Any]:
    """
    Remove consecutive duplicate messages from a list.
    Enhanced version with better handling of different message types.
    
    Parameters
    ----------
    messages : List[Any]
        List of messages to deduplicate.
        
    Returns
    -------
    List[Any]
        List with consecutive duplicates removed.
    """
    if not messages:
        return []
        
    unique_messages = []
    prev_content = None

    for msg in messages:
        # Handle different message types
        current_content = None
        if hasattr(msg, 'content'):
            current_content = msg.content
        elif isinstance(msg, dict):
            current_content = msg.get('content', str(msg))
        else:
            current_content = str(msg)
            
        if current_content != prev_content:
            unique_messages.append(msg)
        prev_content = current_content

    return unique_messages

def extract_a2a_metadata(response_text: str) -> dict:
    """
    Extract A2A protocol metadata from response text.
    
    Parameters
    ----------
    response_text : str
        The response text to analyze.
        
    Returns
    -------
    dict
        Extracted metadata.
    """
    metadata = {
        "timestamp": datetime.now().isoformat(),
        "has_code": bool(re.search(r'```\w*\n.*?\n```', response_text, re.DOTALL)),
        "has_data": bool(re.search(r'(dataframe|dataset|csv|json)', response_text, re.IGNORECASE)),
        "has_visualization": bool(re.search(r'(plot|chart|graph|figure)', response_text, re.IGNORECASE)),
        "word_count": len(response_text.split()),
        "line_count": len(response_text.split('\n')),
    }
    
    return metadata

def format_for_streamlit(text: str) -> str:
    """
    Format text for optimal Streamlit display.
    
    Parameters
    ----------
    text : str
        Text to format.
        
    Returns
    -------
    str
        Streamlit-formatted text.
    """
    if not text:
        return ""
    
    # Ensure proper markdown formatting
    lines = text.split('\n')
    formatted_lines = []
    
    for line in lines:
        # Add proper spacing around headers
        if line.strip().startswith('#'):
            if formatted_lines and formatted_lines[-1].strip():
                formatted_lines.append('')
            formatted_lines.append(line)
            formatted_lines.append('')
        else:
            formatted_lines.append(line)
    
    return '\n'.join(formatted_lines) 